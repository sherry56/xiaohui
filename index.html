<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç°ç¼–ç¨‹ Â· çº¯éª¨éª¼ç®—æ³•æ‰‹åŠ¿å¼•æ“</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root { --primary: #00f3ff; --bg: #05070a; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: monospace; user-select: none; }
        
        /* 3D å®¹å™¨ */
        #canvas-container { position: absolute; width: 100vw; height: 100vh; z-index: 1; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        /* è°ƒè¯•é¢æ¿ */
        .debug-panel {
            background: rgba(0, 0, 0, 0.8); border: 1px solid var(--primary); color: #fff;
            padding: 15px; border-radius: 8px; width: 300px; pointer-events: auto;
        }
        .debug-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; }
        .val { color: var(--primary); font-weight: bold; }
        .cam-preview {
            width: 100%; height: 200px; background: #222; margin-bottom: 10px; position: relative;
            transform: scaleX(-1); /* é•œåƒ */
        }
        #webcam, #output_canvas { position: absolute; top:0; left:0; width:100%; height:100%; object-fit: cover; }

        /* Toast */
        #toast {
            position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
            background: rgba(0, 243, 255, 0.2); border: 1px solid var(--primary); color: #fff;
            padding: 10px 30px; border-radius: 20px; font-weight: bold; opacity: 0; transition: 0.3s;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.5); z-index: 100;
        }

        /* Loading */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; justify-content: center; align-items: center; color: var(--primary); z-index: 999;
            flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="loading">
        <h2>æ­£åœ¨åŠ è½½è§†è§‰æ¨¡å‹...</h2>
        <p>è¯·ç¡®ä¿ä½¿ç”¨ Live Server (localhost) è¿è¡Œ</p>
    </div>

    <div id="toast">æç¤º</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <!-- å·¦ä¾§ï¼šè§†è§‰æ•°æ® -->
        <div class="debug-panel">
            <h3 style="color:var(--primary); margin-top:0; border-bottom:1px solid #555; padding-bottom:5px;">éª¨éª¼æ•°æ®åˆ†æ (Skeleton Analysis)</h3>
            <div class="cam-preview">
                <video id="webcam" autoplay playsinline muted></video>
                <canvas id="output_canvas"></canvas>
            </div>
            
            <div class="debug-row"><span>çŠ¶æ€ (Action):</span> <span class="val" id="d-action">IDLE</span></div>
            <div class="debug-row"><span>æåˆè·ç¦» (Pinch):</span> <span class="val" id="d-pinch">0.00</span></div>
            <div class="debug-row"><span>å¼ å¼€ç¨‹åº¦ (Open):</span> <span class="val" id="d-open">0.00</span></div>
            <div class="debug-row"><span>æŒ¥æ‰‹é€Ÿåº¦ (Swipe Y):</span> <span class="val" id="d-swipe">0.00</span></div>
            
            <button onclick="startCam()" style="width:100%; margin-top:10px; padding:8px; background:var(--primary); border:none; font-weight:bold; cursor:pointer;">å¯åŠ¨æ‘„åƒå¤´</button>
        </div>

        <!-- å³ä¾§ï¼šè¯´æ˜ -->
        <div class="debug-panel" style="text-align: right;">
            <h3 style="color:var(--primary); margin-top:0;">äº¤äº’é€»è¾‘</h3>
            <div style="font-size:12px; line-height:1.8;">
                ğŸ‘Œ <b>æåˆ</b>: è·ç¦» < 0.06 -> æ—‹è½¬<br>
                ğŸ– <b>å¼ å¼€</b>: å¹³å‡æŒ‡è· > 0.35 -> ç‚¸è£‚<br>
                ğŸ‘‡ <b>ä¸‹æŒ¥</b>: è…•éƒ¨é€Ÿåº¦Y > 0.3 -> å´©å¡Œ<br>
                ğŸ‘† <b>ä¸ŠæŒ¥</b>: è…•éƒ¨é€Ÿåº¦Y < -0.3 -> é‡ç»„<br>
                âœŠ <b>æ¡æ‹³</b>: å¹³å‡æŒ‡è· < 0.18 -> æš‚åœ<br>
            </div>
        </div>
    </div>

    <!-- æ¨¡å—åŒ–è„šæœ¬ -->
    <script type="module">
        import { FilesetResolver, GestureRecognizer, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        /* ==================== 1. å…¨å±€é…ç½® ==================== */
        const state = {
            action: 'NORMAL', // NORMAL, SHATTER, FALLING, PAUSED
            isPinching: false,
            pinchStart: {x:0, y:0},
            targetRot: {x:0, y:0},
            wristHistory: [],
            lockTimer: 0
        };

        const dom = {
            video: document.getElementById('webcam'),
            canvas: document.getElementById('output_canvas'),
            loading: document.getElementById('loading'),
            dPinch: document.getElementById('d-pinch'),
            dOpen: document.getElementById('d-open'),
            dSwipe: document.getElementById('d-swipe'),
            dAction: document.getElementById('d-action'),
            toast: document.getElementById('toast')
        };

        /* ==================== 2. AI è§†è§‰å¼•æ“ (éª¨éª¼æ•°æ®æº) ==================== */
        let gestureRecognizer;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;

        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode,
                    numHands: 1
                });
                dom.loading.style.display = 'none';
            } catch (e) {
                alert("æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ä½¿ç”¨ localhost è¿è¡Œã€‚");
            }
        }

        window.startCam = () => {
            navigator.mediaDevices.getUserMedia({video: true}).then(stream => {
                dom.video.srcObject = stream;
                dom.video.addEventListener('loadeddata', predictWebcam);
            });
        };

        const drawingUtils = new DrawingUtils(dom.canvas.getContext("2d"));

        async function predictWebcam() {
            if(dom.video.currentTime !== lastVideoTime) {
                lastVideoTime = dom.video.currentTime;
                const results = gestureRecognizer.recognizeForVideo(dom.video, Date.now());
                
                // ç»˜åˆ¶éª¨æ¶
                drawSkeleton(results);
                
                // æ ¸å¿ƒï¼šåŸºäºéª¨éª¼çš„è‡ªå®šä¹‰é€»è¾‘
                if(results.landmarks.length > 0) {
                    analyzeSkeleton(results.landmarks[0]);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function drawSkeleton(results) {
            const ctx = dom.canvas.getContext("2d");
            ctx.clearRect(0,0, dom.canvas.width, dom.canvas.height);
            dom.canvas.width = dom.video.videoWidth;
            dom.canvas.height = dom.video.videoHeight;
            if(results.landmarks && results.landmarks[0]) {
                drawingUtils.drawConnectors(results.landmarks[0], GestureRecognizer.HAND_CONNECTIONS, {color: "#00f3ff", lineWidth: 2});
                drawingUtils.drawLandmarks(results.landmarks[0], {color: "#fff", radius: 2});
            }
        }

        /* ==================== 3. æ ¸å¿ƒï¼šéª¨éª¼å‡ ä½•ç®—æ³• (The Logic) ==================== */
        function analyzeSkeleton(lm) {
            if(state.lockTimer > 0) { state.lockTimer--; return; }

            // 1. æå–å…³é”®ç‚¹ (Data extraction)
            const thumb = lm[4];
            const index = lm[8];
            const wrist = lm[0];
            
            // 2. è®¡ç®—å‡ ä½•ç‰¹å¾ (Geometry Calculation)
            
            // A. æåˆè·ç¦» (æ¬§å‡ é‡Œå¾—è·ç¦» 3D)
            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y, thumb.z - index.z);
            
            // B. å¼ å¼€ç¨‹åº¦ (æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»)
            const tips = [4, 8, 12, 16, 20];
            let totalDist = 0;
            tips.forEach(i => totalDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
            const avgOpen = totalDist / 5;

            // C. æŒ¥æ‰‹é€Ÿåº¦ (åŸºäºå†å²ä½ç½®)
            state.wristHistory.push({x: wrist.x, y: wrist.y, t: Date.now()});
            if(state.wristHistory.length > 6) state.wristHistory.shift();
            
            let swipeDy = 0, swipeDx = 0;
            if(state.wristHistory.length === 6) {
                const start = state.wristHistory[0];
                const end = state.wristHistory[5];
                swipeDy = (end.y - start.y) * 10; // æ”¾å¤§ç³»æ•°
                swipeDx = (end.x - start.x) * 10;
            }

            // æ›´æ–°è°ƒè¯•é¢æ¿
            dom.dPinch.innerText = pinchDist.toFixed(3);
            dom.dOpen.innerText = avgOpen.toFixed(3);
            dom.dSwipe.innerText = swipeDy.toFixed(3);

            // 3. çŠ¶æ€æœºåˆ¤æ–­ (State Machine)

            // --- ä¼˜å…ˆçº§ 1: æš‚åœ (æ¡æ‹³) ---
            if(avgOpen < 0.18) {
                if(state.action !== 'PAUSED') {
                    state.action = 'PAUSED';
                    showToast("âœŠ å·²å†»ç»“ (Paused)");
                } else {
                    state.action = 'NORMAL';
                    showToast("âœŠ å·²æ¢å¤ (Resumed)");
                }
                state.lockTimer = 30; // å†·å´é˜²æ­¢é—ªçƒ
                dom.dAction.innerText = "FIST (PAUSE)";
                return;
            }
            if(state.action === 'PAUSED') return;

            // --- ä¼˜å…ˆçº§ 2: æåˆæ—‹è½¬ ---
            const pinchEnter = 0.06;
            const pinchExit = 0.10; // ç£å¸é˜²æŠ–
            const threshold = state.isPinching ? pinchExit : pinchEnter;

            if(pinchDist < threshold) {
                if(!state.isPinching) {
                    state.isPinching = true;
                    state.pinchStart = {x: thumb.x, y: thumb.y};
                }
                // è®¡ç®—æ—‹è½¬ Delta
                const dx = (thumb.x - state.pinchStart.x) * 5;
                const dy = (thumb.y - state.pinchStart.y) * 5;
                state.targetRot.y -= dx * 0.1;
                state.targetRot.x += dy * 0.1;
                
                dom.dAction.innerText = "ğŸ‘Œ PINCH ROTATE";
                return; // æåˆæ—¶é˜»æ–­å…¶ä»–æ‰‹åŠ¿
            } else {
                state.isPinching = false;
            }

            // --- ä¼˜å…ˆçº§ 3: æŒ¥æ‰‹ (Swipe) ---
            if(Math.abs(swipeDy) > 0.8) { // é˜ˆå€¼
                if(swipeDy > 0) { // Yå‘ä¸‹å¢åŠ 
                    state.action = 'FALLING';
                    dom.dAction.innerText = "ğŸ‘‡ SWIPE DOWN";
                    showToast("ğŸ‘‡ å´©å¡Œ (Collapse)");
                    resetVelocity();
                } else {
                    state.action = 'NORMAL';
                    dom.dAction.innerText = "ğŸ‘† SWIPE UP";
                    showToast("ğŸ‘† é‡ç»„ (Reassemble)");
                }
                state.lockTimer = 20;
                return;
            }
            
            if(Math.abs(swipeDx) > 0.8) {
                changeTheme();
                state.lockTimer = 20;
                showToast("â†”ï¸ æ¢è‰² (Theme)");
                return;
            }

            // --- ä¼˜å…ˆçº§ 4: å¼ å¼€ç‚¸è£‚ ---
            if(avgOpen > 0.35) {
                state.action = 'SHATTER';
                dom.dAction.innerText = "ğŸ– OPEN (SHATTER)";
            } else if(state.action === 'SHATTER') {
                state.action = 'NORMAL'; // è‡ªåŠ¨æ¢å¤
            } else {
                dom.dAction.innerText = "IDLE";
            }
        }

        /* ==================== 4. Three.js ç²’å­ç‰¹æ•ˆ ==================== */
        let scene, camera, renderer, particles, originalPos, velocities, explosionDirs;
        let themes = [0x00f3ff, 0xff0055, 0xccff00, 0xbd00ff];
        let themeIdx = 0;

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.z = 160;

            renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticles();
            animate();
        }

        function createParticles() {
            const cvs = document.createElement('canvas');
            cvs.width = 1024; cvs.height = 256;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,1024,256);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 150px monospace';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText("å°ç°ç¼–ç¨‹", 512, 128);

            const data = ctx.getImageData(0,0,1024,256).data;
            const points = [];
            
            for(let y=0; y<256; y+=3) {
                for(let x=0; x<1024; x+=3) {
                    if(data[(y*1024+x)*4] > 128) {
                        points.push((x-512)*0.4, -(y-128)*0.4, 0);
                    }
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            originalPos = geo.attributes.position.clone();
            velocities = new Float32Array(points.length);
            explosionDirs = new Float32Array(points.length);

            // é¢„è®¡ç®—çˆ†ç‚¸
            for(let i=0; i<points.length; i+=3) {
                const x=points[i], y=points[i+1];
                const len = Math.sqrt(x*x+y*y)+0.1;
                explosionDirs[i] = x/len + (Math.random()-0.5);
                explosionDirs[i+1] = y/len + (Math.random()-0.5);
                explosionDirs[i+2] = (Math.random()-0.5)*2;
            }

            particles = new THREE.Points(geo, new THREE.PointsMaterial({
                color: themes[0], size: 1.0, transparent: true, opacity: 0.9
            }));
            scene.add(particles);
        }

        function updatePhysics() {
            if(!particles || state.action === 'PAUSED') return;

            const pos = particles.geometry.attributes.position.array;
            const orig = originalPos.array;

            // æ—‹è½¬å¹³æ»‘
            particles.rotation.x += (state.targetRot.x - particles.rotation.x) * 0.1;
            particles.rotation.y += (state.targetRot.y - particles.rotation.y) * 0.1;

            for(let i=0; i<pos.length; i+=3) {
                if(state.action === 'SHATTER') {
                    // ç‚¸è£‚é€»è¾‘
                    pos[i] += (orig[i] + explosionDirs[i]*30 - pos[i]) * 0.1;
                    pos[i+1] += (orig[i+1] + explosionDirs[i+1]*30 - pos[i+1]) * 0.1;
                    pos[i+2] += (orig[i+2] + explosionDirs[i+2]*30 - pos[i+2]) * 0.1;
                } 
                else if (state.action === 'FALLING') {
                    // å´©å¡Œé€»è¾‘
                    velocities[i+1] -= 0.05; // é‡åŠ›
                    velocities[i] += (Math.random()-0.5)*0.1;
                    pos[i] += velocities[i];
                    pos[i+1] += velocities[i+1];
                    pos[i+2] += velocities[i+2];
                    if(pos[i+1] < -120) { pos[i+1]=-120; velocities[i+1]*=-0.5; }
                } 
                else {
                    // èšåˆé€»è¾‘
                    pos[i] += (orig[i] - pos[i]) * 0.15;
                    pos[i+1] += (orig[i+1] - pos[i+1]) * 0.15;
                    pos[i+2] += (orig[i+2] - pos[i+2]) * 0.15;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function resetVelocity() {
            for(let i=0; i<velocities.length; i++) velocities[i] = (Math.random()-0.5);
        }

        function changeTheme() {
            themeIdx = (themeIdx+1)%themes.length;
            particles.material.color.setHex(themes[themeIdx]);
        }

        function showToast(msg) {
            dom.toast.innerText = msg;
            dom.toast.style.opacity = 1;
            setTimeout(()=>dom.toast.style.opacity=0, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        initVision();
        initThree();

    </script>
</body>
</html>
