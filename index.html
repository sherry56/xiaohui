<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç°ç¼–ç¨‹ Â· åŒæ¨¡äº¤äº’æ ¸å¿ƒ (Mouse + AI Vision)</title>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Vision -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #00f3ff;
            --bg: #05070a;
            --glass: rgba(20, 30, 40, 0.7);
            --border: rgba(255, 255, 255, 0.15);
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Microsoft YaHei', sans-serif; user-select: none; }

        /* 3D å®¹å™¨ */
        #canvas-container { position: absolute; width: 100vw; height: 100vh; z-index: 1; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        header { text-align: center; pointer-events: auto; text-shadow: 0 0 10px var(--primary); }
        h1 { color: #fff; margin: 0; font-size: 2rem; letter-spacing: 4px; }
        .subtitle { color: var(--primary); font-size: 0.9rem; opacity: 0.8; }

        /* ä¸»å¸ƒå±€ */
        .layout { display: flex; flex: 1; justify-content: space-between; align-items: flex-start; margin-top: 20px; }

        /* é¢æ¿é€šç”¨ */
        .panel {
            background: var(--glass); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-radius: 12px; padding: 15px;
            width: 260px; pointer-events: auto; color: #fff; transition: border 0.3s;
        }
        .panel:hover { border-color: var(--primary); }
        .panel-title { border-bottom: 1px solid var(--border); padding-bottom: 8px; margin-bottom: 10px; font-weight: bold; color: var(--primary); }

        /* å·¦ä¾§æ‘„åƒå¤´é¢„è§ˆ */
        .cam-box {
            width: 100%; height: 180px; background: #000; border-radius: 8px; overflow: hidden; position: relative; border: 1px solid #333;
        }
        #webcam, #output_canvas { position: absolute; top:0; left:0; width:100%; height:100%; transform: scaleX(-1); object-fit: cover; }
        
        .status-row { display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px; color: #aaa; }
        .val { color: var(--primary); font-weight: bold; }

        /* å³ä¾§æ‰‹åŠ¿è¡¨ */
        .gesture-list div { font-size: 12px; margin-bottom: 5px; border-bottom: 1px dashed rgba(255,255,255,0.1); padding-bottom: 2px; }

        /* Toast æç¤º */
        #toast {
            position: fixed; top: 15%; right: 50%; transform: translateX(50%);
            background: rgba(0, 243, 255, 0.2); border: 1px solid var(--primary);
            color: #fff; padding: 10px 20px; border-radius: 20px;
            font-weight: bold; opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3); z-index: 100;
        }

        /* Loading */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: var(--primary); font-size: 1.5rem;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--primary);
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        button {
            width: 100%; padding: 8px; margin-top: 10px; background: rgba(0,255,255,0.1);
            border: 1px solid var(--primary); color: var(--primary); cursor: pointer; border-radius: 4px;
        }
        button:hover { background: var(--primary); color: #000; }

        /* æš‚åœé®ç½© */
        #pause-mask {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 5rem; color: rgba(255,255,255,0.1); font-weight: 900; display: none;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åŠ è½½ AI è§†è§‰æ¨¡å‹...</div>
        <div style="font-size: 0.8rem; color: #666; margin-top: 10px;">(é¦–æ¬¡åŠ è½½éœ€çº¦ 10ç§’)</div>
    </div>

    <div id="toast">æç¤ºä¿¡æ¯</div>
    <div id="pause-mask">PAUSED</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>å°ç°ç¼–ç¨‹</h1>
            <div class="subtitle">AI Vision + Mouse Dual Interaction</div>
        </header>

        <div class="layout">
            <!-- å·¦ä¾§ï¼šè§†è§‰åé¦ˆ -->
            <div class="panel">
                <div class="panel-title">è§†è§‰ä¼ æ„Ÿå™¨ (Vision)</div>
                <div class="cam-box">
                    <video id="webcam" autoplay playsinline muted></video>
                    <canvas id="output_canvas"></canvas>
                </div>
                <div class="status-row"><span>Input Mode:</span> <span class="val" id="st-mode">MOUSE</span></div>
                <div class="status-row"><span>Status:</span> <span class="val" id="st-status">IDLE</span></div>
                <div class="status-row"><span>Pinch Dist:</span> <span class="val" id="st-pinch">0.00</span></div>
                <button id="btn-cam">å¼€å¯æ‘„åƒå¤´</button>
            </div>

            <!-- å³ä¾§ï¼šæŒ‡ä»¤è¡¨ -->
            <div class="panel">
                <div class="panel-title">äº¤äº’æŒ‡ä»¤è¡¨</div>
                <div class="gesture-list">
                    <div>ğŸ–±ï¸ <b>é¼ æ ‡æ¨¡å¼</b>ï¼šç§»åŠ¨æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾</div>
                    <div>ğŸ‘Œ <b>æåˆ (Pinch)</b>ï¼šç‰©ç†æ—‹è½¬æ¨¡å‹</div>
                    <div>ğŸ– <b>å¼ å¼€ (Open)</b>ï¼šç²’å­ç‚¸è£‚æ•£å¼€</div>
                    <div>ğŸ‘‡ <b>ä¸‹æŒ¥ (Swipe Down)</b>ï¼šç²’å­é‡åŠ›å´©å¡Œ</div>
                    <div>ğŸ‘† <b>ä¸ŠæŒ¥ (Swipe Up)</b>ï¼šç²’å­é‡ç»„å¤åŸ</div>
                    <div>â†”ï¸ <b>ä¾§æŒ¥ (Swipe Side)</b>ï¼šåˆ‡æ¢ä¸»é¢˜è‰²</div>
                    <div>ğŸ‘ <b>ç«–å¤§æ‹‡æŒ‡</b>ï¼šç¼–è¯‘æˆåŠŸç‰¹æ•ˆ</div>
                    <div>âœŠ <b>æ¡æ‹³ (Fist)</b>ï¼šæš‚åœ/å†»ç»“</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, GestureRecognizer, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        /* ==================== 1. å…¨å±€é…ç½® ==================== */
        const config = {
            themes: [0x00f3ff, 0xbd00ff, 0x00ff9d, 0xffaa00],
            currTheme: 0,
            pinchEnter: 0.06,  // æåˆçµæ•åº¦
            pinchExit: 0.12,   // æåˆé˜²æŠ–
            openThresh: 0.28,  // å¼ å¼€ç‚¸è£‚é˜ˆå€¼
            swipeSpeed: 0.015, // æŒ¥æ‰‹é€Ÿåº¦é˜ˆå€¼
            mouseSense: 0.0005 // é¼ æ ‡çµæ•åº¦
        };

        const state = {
            mode: 'MOUSE', // MOUSE or HAND
            action: 'NORMAL', // NORMAL, SHATTER, FALLING, PAUSED
            rotation: { x: 0, y: 0 }, // ç›®æ ‡æ—‹è½¬
            mouse: { x: 0, y: 0 },
            handStart: { x: 0, y: 0 }, // æåˆèµ·å§‹ç‚¹
            isPinching: false,
            gestureLock: 0 // å†·å´æ—¶é—´
        };

        const dom = {
            video: document.getElementById('webcam'),
            canvas2d: document.getElementById('output_canvas'),
            stMode: document.getElementById('st-mode'),
            stStatus: document.getElementById('st-status'),
            stPinch: document.getElementById('st-pinch'),
            toast: document.getElementById('toast'),
            pauseMask: document.getElementById('pause-mask'),
            loading: document.getElementById('loading')
        };

        /* ==================== 2. Three.js ç²’å­ç³»ç»Ÿ ==================== */
        let scene, camera, renderer, particles;
        let originalPos, velocities, explosionDirs; // Buffers

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x05070a, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticles();

            // é¼ æ ‡ç›‘å¬
            document.addEventListener('mousemove', (e) => {
                if(state.mode === 'MOUSE') {
                    state.mouse.x = (e.clientX - window.innerWidth/2) * config.mouseSense;
                    state.mouse.y = (e.clientY - window.innerHeight/2) * config.mouseSense;
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createParticles() {
            const w = 1024, h = 256;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            const ctx = cvs.getContext('2d');
            
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = 'bold 160px "Microsoft YaHei", sans-serif';
            ctx.fillText("å°ç°ç¼–ç¨‹", w/2, h/2);

            const data = ctx.getImageData(0,0,w,h).data;
            const points = [];
            const stride = 2; // é‡‡æ ·å¯†åº¦

            for(let y=0; y<h; y+=stride) {
                for(let x=0; x<w; x+=stride) {
                    if(data[(y*w+x)*4] > 128) {
                        points.push((x-w/2)*0.4, -(y-h/2)*0.4, 0);
                    }
                }
            }

            const geo = new THREE.BufferGeometry();
            const posAttr = new THREE.Float32BufferAttribute(points, 3);
            geo.setAttribute('position', posAttr);
            
            originalPos = posAttr.clone();
            velocities = new Float32Array(points.length);
            explosionDirs = new Float32Array(points.length);

            // é¢„è®¡ç®—çˆ†ç‚¸å‘é‡
            for(let i=0; i<points.length; i+=3) {
                const x = points[i], y = points[i+1];
                const len = Math.sqrt(x*x + y*y) + 0.01;
                explosionDirs[i] = x/len + (Math.random()-0.5);
                explosionDirs[i+1] = y/len + (Math.random()-0.5);
                explosionDirs[i+2] = (Math.random()-0.5)*2;
            }

            const mat = new THREE.PointsMaterial({
                color: config.themes[0],
                size: 0.8,
                transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        /* ==================== 3. ç‰©ç†å¾ªç¯ ==================== */
        function updatePhysics() {
            if(!particles || state.action === 'PAUSED') return;

            const pos = particles.geometry.attributes.position.array;
            const orig = originalPos.array;
            
            // æ—‹è½¬é€»è¾‘ (æ··åˆ Mouse å’Œ Hand)
            let targetRotX, targetRotY;
            if(state.mode === 'MOUSE') {
                targetRotX = state.mouse.y;
                targetRotY = state.mouse.x;
            } else {
                targetRotX = state.rotation.x;
                targetRotY = state.rotation.y;
            }
            // æƒ¯æ€§å¹³æ»‘
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.1;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;


            // ç²’å­ä½ç½®çŠ¶æ€æœº
            for(let i=0; i<pos.length; i+=3) {
                if(state.action === 'SHATTER') {
                    // ç‚¸è£‚
                    const speed = 30;
                    pos[i] += (orig[i] + explosionDirs[i]*speed - pos[i]) * 0.1;
                    pos[i+1] += (orig[i+1] + explosionDirs[i+1]*speed - pos[i+1]) * 0.1;
                    pos[i+2] += (orig[i+2] + explosionDirs[i+2]*speed - pos[i+2]) * 0.1;
                } 
                else if (state.action === 'FALLING') {
                    // ä¸‹è½å´©å¡Œ
                    velocities[i+1] -= 0.05; // é‡åŠ›
                    velocities[i] += (Math.random()-0.5)*0.1;
                    
                    pos[i] += velocities[i];
                    pos[i+1] += velocities[i+1];
                    pos[i+2] += velocities[i+2];

                    if(pos[i+1] < -100) { // åœ°é¢åå¼¹
                        pos[i+1] = -100;
                        velocities[i+1] *= -0.4;
                    }
                }
                else {
                    // NORMAL: èšåˆé‡ç»„
                    pos[i] += (orig[i] - pos[i]) * 0.1;
                    pos[i+1] += (orig[i+1] - pos[i+1]) * 0.1;
                    pos[i+2] += (orig[i+2] - pos[i+2]) * 0.1;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        /* ==================== 4. AI è§†è§‰é€»è¾‘ ==================== */
        let gestureRecognizer;
        let lastVideoTime = -1;
        let wristHistory = []; // ç”¨äºæŒ¥æ‰‹æ£€æµ‹

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            dom.loading.style.display = 'none';
        }

        async function predictWebcam() {
            const now = Date.now();
            if(dom.video.currentTime !== lastVideoTime && gestureRecognizer) {
                lastVideoTime = dom.video.currentTime;
                const result = gestureRecognizer.recognizeForVideo(dom.video, now);
                processGestures(result);
                drawDebug(result);
            }
            requestAnimationFrame(predictWebcam);
        }

        // æ ¸å¿ƒæ‰‹åŠ¿è§£æ
        function processGestures(result) {
            if(!result.landmarks || result.landmarks.length === 0) {
                state.mode = 'MOUSE';
                dom.stMode.innerText = 'MOUSE (No Hand)';
                return;
            }

            // åˆ‡æ¢ä¸ºæ‰‹åŠ¿æ¨¡å¼
            state.mode = 'HAND';
            dom.stMode.innerText = 'HAND CONTROL';
            
            const lm = result.landmarks[0];
            const handedness = result.handedness[0].categoryName; // Left or Right
            
            // å…³é”®ç‚¹
            const thumb = lm[4], index = lm[8], wrist = lm[0];
            
            // 1. è®¡ç®—è·ç¦»
            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y, thumb.z - index.z);
            let totalTipDist = 0;
            [4,8,12,16,20].forEach(i => totalTipDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
            const avgOpenDist = totalTipDist / 5;

            dom.stPinch.innerText = pinchDist.toFixed(3);

            // å†·å´æ—¶é—´é€’å‡
            if(state.gestureLock > 0) {
                state.gestureLock--;
                return;
            }

            // A. æ¡æ‹³ (Fist) -> æš‚åœ
            // ç®€å•åˆ¤æ–­ï¼šæŒ‡å°–åˆ°æ‰‹è…•è·ç¦»éƒ½å¾ˆå°
            if(avgOpenDist < 0.15) {
                if(state.action !== 'PAUSED') {
                    state.action = 'PAUSED';
                    dom.pauseMask.style.display = 'block';
                    showToast("âœŠ æš‚åœ Frozen");
                    state.gestureLock = 30;
                } else {
                    state.action = 'NORMAL';
                    dom.pauseMask.style.display = 'none';
                    showToast("âœŠ æ¢å¤ Resumed");
                    state.gestureLock = 30;
                }
                return; // æš‚åœä¼˜äºå…¶ä»–é€»è¾‘
            }

            if(state.action === 'PAUSED') return; // æš‚åœæ—¶ä¸å¤„ç†å…¶ä»–

            // B. æåˆæ—‹è½¬ (Pinch to Rotate) - çŠ¶æ€æœº
            let pinchTrigger = state.isPinching ? config.pinchExit : config.pinchEnter;
            
            if(pinchDist < pinchTrigger) {
                if(!state.isPinching) {
                    state.isPinching = true;
                    state.handStart = { x: thumb.x, y: thumb.y };
                }
                // è®¡ç®— Delta æ˜ å°„åˆ°æ—‹è½¬
                const dx = (thumb.x - state.handStart.x) * 3; 
                const dy = (thumb.y - state.handStart.y) * 3;
                
                // å åŠ æ—‹è½¬ (å¹³æ»‘)
                state.rotation.y -= dx * 0.1;
                state.rotation.x += dy * 0.1;
                
                dom.stStatus.innerText = "PINCH ROTATING";
                return; // æåˆæ—¶é˜»æ–­å…¶ä»–
            } else {
                state.isPinching = false;
            }

            // C. åŠ¨æ€æŒ¥æ‰‹ (Swipes)
            // è®°å½•å†å²ä½ç½®
            wristHistory.push({x: wrist.x, y: wrist.y, t: Date.now()});
            if(wristHistory.length > 8) wristHistory.shift();
            
            if(wristHistory.length === 8) {
                const start = wristHistory[0], end = wristHistory[7];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const dt = end.t - start.t;
                const speed = Math.hypot(dx, dy) / dt * 1000; // units/sec

                // ä¸‹æŒ¥ -> å´©å¡Œ
                if(dy > 0.15) { // Yåæ ‡å‘ä¸‹å¢åŠ  (MediaPipe Yå‘ä¸‹ä¸ºæ­£)
                    if(state.action !== 'FALLING') {
                        state.action = 'FALLING';
                        // é‡ç½®é€Ÿåº¦
                        for(let i=0; i<velocities.length; i++) velocities[i] = (Math.random()-0.5);
                        showToast("ğŸ‘‡ å´©å¡Œ Falling");
                        state.gestureLock = 40;
                    }
                }
                // ä¸ŠæŒ¥ -> é‡ç»„
                else if(dy < -0.15) {
                    if(state.action !== 'NORMAL') {
                        state.action = 'NORMAL';
                        showToast("ğŸ‘† é‡ç»„ Reassemble");
                        state.gestureLock = 40;
                    }
                }
                // ä¾§æŒ¥ -> æ¢è‰²
                else if(Math.abs(dx) > 0.2) {
                    switchTheme();
                    showToast("â†”ï¸ æ¢è‰² Theme Changed");
                    state.gestureLock = 40;
                }
            }

            // D. å¼ æ‰‹ç‚¸è£‚ (Open)
            if(avgOpenDist > config.openThresh) {
                state.action = 'SHATTER';
                dom.stStatus.innerText = "OPEN SHATTER";
            } else if (state.action === 'SHATTER') {
                state.action = 'NORMAL'; // æ¢å¤
            }

            // E. ç«–å¤§æ‹‡æŒ‡ (Thumb Up)
            // ç®€å•å‡ ä½•ï¼šæ‹‡æŒ‡æŒ‡å°–é«˜äºIPå…³èŠ‚ï¼Œå…¶ä»–æŒ‡å°–ä½äºMCP
            const thumbIsUp = thumb.y < lm[3].y; // Yè¶Šå°è¶Šé«˜
            const othersCurled = lm[12].y > lm[9].y && lm[16].y > lm[13].y;
            
            if(thumbIsUp && othersCurled && !state.isPinching) {
                showToast("ğŸ‘ ç¼–è¯‘é€šè¿‡ Success");
                // ç¬æ—¶ç‰¹æ•ˆï¼šå˜ç»¿
                const oldC = particles.material.color.getHex();
                particles.material.color.setHex(0x00ff00);
                setTimeout(() => particles.material.color.setHex(config.themes[config.currTheme]), 1000);
                state.gestureLock = 60;
            }
        }

        // è°ƒè¯•ç»˜åˆ¶
        const drawingUtils = new DrawingUtils(dom.canvas2d.getContext('2d'));
        function drawDebug(result) {
            const ctx = dom.canvas2d.getContext('2d');
            ctx.clearRect(0,0, dom.canvas2d.width, dom.canvas2d.height);
            dom.canvas2d.width = dom.video.videoWidth;
            dom.canvas2d.height = dom.video.videoHeight;
            if(result.landmarks) {
                for(const lm of result.landmarks) {
                    drawingUtils.drawConnectors(lm, GestureRecognizer.HAND_CONNECTIONS, {color:"#00f3ff", lineWidth: 2});
                    drawingUtils.drawLandmarks(lm, {color:"#fff", radius:2});
                }
            }
        }

        /* ==================== 5. è¾…åŠ©åŠŸèƒ½ ==================== */
        function switchTheme() {
            config.currTheme = (config.currTheme + 1) % config.themes.length;
            particles.material.color.setHex(config.themes[config.currTheme]);
        }

        function showToast(msg) {
            dom.toast.innerText = msg;
            dom.toast.style.opacity = 1;
            dom.toast.style.top = '20%';
            setTimeout(() => {
                dom.toast.style.opacity = 0;
                dom.toast.style.top = '15%';
            }, 2000);
        }

        document.getElementById('btn-cam').addEventListener('click', () => {
            navigator.mediaDevices.getUserMedia({video: true}).then(stream => {
                dom.video.srcObject = stream;
                dom.video.addEventListener('loadeddata', predictWebcam);
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // å…¥å£
        initThree();
        initAI();
        animate();

    </script>
</body>
</html>
