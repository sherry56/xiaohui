<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç°ç¼–ç¨‹ Â· 3Dç²’å­æ ¸å¿ƒ (Compact & Mouse Control)</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root {
            --primary: #00f3ff;
            --bg: #05070a;
            --glass: rgba(20, 30, 40, 0.7);
            --border: rgba(255, 255, 255, 0.2);
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; user-select: none; }

        /* å…¨å±å®¹å™¨ */
        #canvas-container { position: absolute; width: 100vw; height: 100vh; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ - æ›´åŠ æç®€ */
        header { text-align: center; pointer-events: auto; margin-top: 20px; text-shadow: 0 0 15px var(--primary); opacity: 0.8; transition: opacity 0.3s; }
        header:hover { opacity: 1; }
        h1 { color: #fff; margin: 0; font-size: 1.8rem; letter-spacing: 4px; }
        .subtitle { color: var(--primary); font-size: 0.8rem; letter-spacing: 2px; }

        /* å¸ƒå±€å®¹å™¨ */
        .layout { display: flex; justify-content: space-between; align-items: flex-end; height: 100%; padding-bottom: 40px; }

        /* é¢æ¿ */
        .panel {
            background: var(--glass); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-radius: 8px; padding: 15px;
            width: 240px; pointer-events: auto; color: #fff; transform: scale(0.9);
            transition: transform 0.2s, border-color 0.2s;
        }
        .panel:hover { transform: scale(1); border-color: var(--primary); }
        .panel-title { 
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; margin-bottom: 10px; 
            font-weight: bold; color: var(--primary); font-size: 0.9rem;
        }

        /* æ‘„åƒå¤´å°çª— */
        .cam-container {
            position: relative; width: 100%; height: 140px; background: #000; 
            border-radius: 4px; overflow: hidden; border: 1px solid #333; margin-bottom: 10px;
        }
        #webcam, #output_canvas { 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            transform: scaleX(-1); object-fit: cover; 
        }

        .status-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; color: #aaa; }
        .val { color: #fff; font-family: monospace; }

        /* æ‰‹åŠ¿åˆ—è¡¨ */
        .gesture-list div { font-size: 12px; margin-bottom: 5px; color: #ccc; }

        /* å¼€å¯æŒ‰é’® */
        button {
            width: 100%; padding: 8px; background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--primary); color: var(--primary); 
            cursor: pointer; border-radius: 4px; transition: 0.3s; font-size: 12px;
        }
        button:hover { background: var(--primary); color: #000; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; }

        /* Toast */
        #toast {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 243, 255, 0.1); border: 1px solid var(--primary);
            color: #fff; padding: 15px 40px; border-radius: 4px;
            font-weight: bold; opacity: 0; transition: opacity 0.3s;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2); pointer-events: none;
            font-size: 1.2rem; letter-spacing: 2px; text-align: center;
        }

        /* Loading */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #05070a; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: var(--primary); transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h3>æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰å¼•æ“...</h3>
        <p style="font-size: 12px; color: #666;">è¯·ä½¿ç”¨ Localhost / Live Server è¿è¡Œ</p>
    </div>

    <div id="toast">æç¤ºä¿¡æ¯</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>å°ç°ç¼–ç¨‹</h1>
            <div class="subtitle">Mouse & Hand Dual Interaction</div>
        </header>

        <div class="layout">
            <!-- å·¦ä¸‹è§’ï¼šè§†è§‰ç›‘æ§ -->
            <div class="panel">
                <div class="panel-title">Visual Core</div>
                <div class="cam-container">
                    <video id="webcam" autoplay playsinline muted></video>
                    <canvas id="output_canvas"></canvas>
                </div>
                <div class="status-row"><span>Mode:</span> <span class="val" id="st-mode">MOUSE CONTROL</span></div>
                <div class="status-row"><span>Status:</span> <span class="val" id="st-status">IDLE</span></div>
                <button id="btn-cam" disabled>å¼€å¯æ‘„åƒå¤´ (Start Cam)</button>
            </div>

            <!-- å³ä¸‹è§’ï¼šæŒ‡ä»¤ -->
            <div class="panel">
                <div class="panel-title">Controls</div>
                <div class="gesture-list">
                    <div>ğŸ–±ï¸ <b>é¼ æ ‡ (Mouse)</b>: ç§»åŠ¨æ—‹è½¬æ¨¡å‹</div>
                    <div>ğŸ‘Œ <b>æåˆ (Pinch)</b>: AI æ—‹è½¬æ§åˆ¶</div>
                    <div>ğŸ– <b>å¼ å¼€ (Open)</b>: ç²’å­ç‚¸è£‚</div>
                    <div>ğŸ‘‡ <b>ä¸‹æŒ¥ (Down)</b>: é‡åŠ›å´©å¡Œ</div>
                    <div>ğŸ‘† <b>ä¸ŠæŒ¥ (Up)</b>: èšåˆé‡ç»„</div>
                    <div>â†”ï¸ <b>ä¾§æŒ¥ (Side)</b>: åˆ‡æ¢ä¸»é¢˜è‰²</div>
                    <div>âœŠ <b>æ¡æ‹³ (Fist)</b>: æš‚åœå†»ç»“</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, GestureRecognizer, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        /* ==================== é…ç½® ==================== */
        const config = {
            colors: [0x00f3ff, 0xbd00ff, 0x00ff9d, 0xffaa00],
            currColor: 0,
            particleSize: 0.6, // ç²’å­å¤§å°
            textSpread: 0.12,  // ã€å…³é”®ã€‘æ–‡å­—ç´§å‡‘åº¦ç³»æ•° (è¶Šå°è¶Šç´§å‡‘)
            mouseSense: 1.2    // é¼ æ ‡æ—‹è½¬çµæ•åº¦
        };

        const state = {
            mode: 'MOUSE', // MOUSE | HAND
            action: 'NORMAL',
            targetRot: { x: 0, y: 0 }, // ç›®æ ‡æ—‹è½¬è§’åº¦
            isPinching: false,
            pinchStart: {x:0, y:0},
            lockTimer: 0
        };

        const dom = {
            video: document.getElementById('webcam'),
            canvas: document.getElementById('output_canvas'),
            btnCam: document.getElementById('btn-cam'),
            loading: document.getElementById('loading-screen'),
            stMode: document.getElementById('st-mode'),
            stStatus: document.getElementById('st-status'),
            toast: document.getElementById('toast')
        };

        let gestureRecognizer;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;

        /* ==================== 1. AI åˆå§‹åŒ– ==================== */
        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode,
                    numHands: 1
                });
                dom.loading.style.opacity = 0;
                setTimeout(() => dom.loading.style.display = 'none', 500);
                dom.btnCam.disabled = false;
            } catch (err) {
                alert("AI æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿ä½¿ç”¨ Localhost è¿è¡Œã€‚");
            }
        }

        /* ==================== 2. Three.js ç²’å­ç³»ç»Ÿ ==================== */
        let scene, camera, renderer, particles, originalPos, velocities, explosionDirs;

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // é›¾åŒ–æ•ˆæœï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0x05070a, 0.002);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 100; // è¿™é‡Œçš„è·ç¦»é…åˆç¼©å°çš„æ–‡å­—ï¼Œæ˜¾å¾—ç‰©ä½“å¾ˆç²¾è‡´

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createParticles();

            // é¼ æ ‡ç›‘å¬ (æ ¸å¿ƒäº¤äº’)
            document.addEventListener('mousemove', (e) => {
                // åªæœ‰åœ¨é¼ æ ‡æ¨¡å¼ä¸‹æ‰æ›´æ–°ç›®æ ‡æ—‹è½¬
                if (state.mode === 'MOUSE') {
                    // å°†é¼ æ ‡åæ ‡æ˜ å°„åˆ° -1 åˆ° 1 ä¹‹é—´
                    const x = (e.clientX / window.innerWidth) * 2 - 1;
                    const y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    // è®¾å®šç›®æ ‡æ—‹è½¬è§’åº¦ (é™åˆ¶å¹…åº¦)
                    state.targetRot.y = x * config.mouseSense; 
                    state.targetRot.x = y * config.mouseSense * 0.5;
                }
            });

            window.addEventListener('resize', onResize);
            animate();
        }

        function createParticles() {
            // ç¦»å± Canvas ç”Ÿæˆæ–‡å­—
            const w = 1024, h = 256;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            const ctx = cvs.getContext('2d');
            
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = 'bold 120px "Microsoft YaHei", sans-serif'; // å­—ä½“ç¨å¾®æ”¹å°ä¸€ç‚¹ç‚¹
            ctx.fillText("å°ç°ç¼–ç¨‹", w/2, h/2);

            const data = ctx.getImageData(0,0,w,h).data;
            const points = [];
            const stride = 2; // é‡‡æ ·è¶Šå°ç²’å­è¶Šå¯†

            for(let y=0; y<h; y+=stride) {
                for(let x=0; x<w; x+=stride) {
                    if(data[(y*w+x)*4] > 128) {
                        // ã€å…³é”®ä¿®æ”¹ã€‘è¿™é‡Œä¹˜ä»¥ config.textSpread (0.12) è®©å­—å˜å¾—å¾ˆå°å¾ˆç´§å‡‘
                        const px = (x - w/2) * config.textSpread;
                        const py = -(y - h/2) * config.textSpread;
                        points.push(px, py, 0);
                    }
                }
            }

            const geo = new THREE.BufferGeometry();
            const posAttr = new THREE.Float32BufferAttribute(points, 3);
            geo.setAttribute('position', posAttr);
            
            originalPos = posAttr.clone();
            velocities = new Float32Array(points.length);
            explosionDirs = new Float32Array(points.length);

            // é¢„è®¡ç®—çˆ†ç‚¸æ–¹å‘
            for(let i=0; i<points.length; i+=3) {
                const px=points[i], py=points[i+1];
                const len = Math.sqrt(px*px + py*py) + 0.1;
                explosionDirs[i] = px/len + (Math.random()-0.5);
                explosionDirs[i+1] = py/len + (Math.random()-0.5);
                explosionDirs[i+2] = (Math.random()-0.5)*3; // Zè½´çˆ†ç‚¸æ›´å‰§çƒˆ
            }

            const mat = new THREE.PointsMaterial({
                color: config.colors[0],
                size: config.particleSize,
                transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        /* ==================== 3. ç‰©ç†ä¸åŠ¨ç”»å¾ªç¯ ==================== */
        function updatePhysics() {
            if(!particles || state.action === 'PAUSED') return;

            const pos = particles.geometry.attributes.position.array;
            const orig = originalPos.array;

            // 1. æ—‹è½¬å¹³æ»‘æ’å€¼ (æ— è®ºæ˜¯é¼ æ ‡æ§åˆ¶è¿˜æ˜¯æ‰‹åŠ¿æ§åˆ¶ï¼Œéƒ½é€šè¿‡ targetRot é©±åŠ¨)
            particles.rotation.x += (state.targetRot.x - particles.rotation.x) * 0.08;
            particles.rotation.y += (state.targetRot.y - particles.rotation.y) * 0.08;

            // 2. ç²’å­ä½ç½®çŠ¶æ€æœº
            for(let i=0; i<pos.length; i+=3) {
                if(state.action === 'SHATTER') {
                    // ç‚¸è£‚
                    const force = 40; 
                    pos[i] += (orig[i] + explosionDirs[i]*force - pos[i]) * 0.1;
                    pos[i+1] += (orig[i+1] + explosionDirs[i+1]*force - pos[i+1]) * 0.1;
                    pos[i+2] += (orig[i+2] + explosionDirs[i+2]*force - pos[i+2]) * 0.1;
                }
                else if(state.action === 'FALLING') {
                    // ä¸‹è½
                    velocities[i+1] -= 0.04; // é‡åŠ›
                    velocities[i] += (Math.random()-0.5)*0.05; // éšæœºæ¼‚ç§»
                    
                    pos[i] += velocities[i];
                    pos[i+1] += velocities[i+1];
                    pos[i+2] += velocities[i+2];

                    // åœ°é¢è¾¹ç•Œ
                    if(pos[i+1] < -60) {
                        pos[i+1] = -60; 
                        velocities[i+1] *= -0.5; // åå¼¹
                    }
                }
                else {
                    // èšåˆ (Normal) - å¼ºåŠ›å›å¼¹
                    pos[i] += (orig[i] - pos[i]) * 0.15;
                    pos[i+1] += (orig[i+1] - pos[i+1]) * 0.15;
                    pos[i+2] += (orig[i+2] - pos[i+2]) * 0.15;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        /* ==================== 4. è§†è§‰é€»è¾‘ (åŒæ¨¡åˆ‡æ¢) ==================== */
        const drawingUtils = new DrawingUtils(dom.canvas.getContext("2d"));
        let wristHistory = [];

        async function predictLoop() {
            if(dom.video.currentTime !== lastVideoTime) {
                lastVideoTime = dom.video.currentTime;
                const results = gestureRecognizer.recognizeForVideo(dom.video, Date.now());
                
                processGesture(results);
                drawSkeleton(results);
            }
            requestAnimationFrame(predictLoop);
        }

        function drawSkeleton(results) {
            const ctx = dom.canvas.getContext("2d");
            ctx.clearRect(0,0, dom.canvas.width, dom.canvas.height);
            dom.canvas.width = dom.video.videoWidth;
            dom.canvas.height = dom.video.videoHeight;
            if(results.landmarks && results.landmarks[0]) {
                drawingUtils.drawConnectors(results.landmarks[0], GestureRecognizer.HAND_CONNECTIONS, {color: "#00f3ff", lineWidth: 2});
                drawingUtils.drawLandmarks(results.landmarks[0], {color: "#fff", radius: 2});
            }
        }

        function processGesture(results) {
            // æ¨¡å¼åˆ¤å®šï¼šæ— æ‰‹ -> é¼ æ ‡æ¨¡å¼
            if(!results.landmarks || results.landmarks.length === 0) {
                if(state.mode !== 'MOUSE') {
                    state.mode = 'MOUSE';
                    dom.stMode.innerText = "MOUSE CONTROL";
                    dom.stMode.style.color = "#ccc";
                    // æ¢å¤é¼ æ ‡å½“å‰ä½ç½®
                    state.targetRot.x = 0; state.targetRot.y = 0;
                }
                return;
            }

            // æœ‰æ‰‹ -> æ‰‹åŠ¿æ¨¡å¼
            state.mode = 'HAND';
            dom.stMode.innerText = "HAND TRACKING";
            dom.stMode.style.color = "#00f3ff";

            if(state.lockTimer > 0) { state.lockTimer--; return; }

            const lm = results.landmarks[0];
            const thumb = lm[4], index = lm[8], wrist = lm[0];

            // è®¡ç®—å…³é”®æ•°æ®
            const dist = (a, b) => Math.hypot(a.x-b.x, a.y-b.y, a.z-b.z);
            const pinchDist = dist(thumb, index);
            let openSum = 0; [4,8,12,16,20].forEach(i => openSum += dist(lm[i], wrist));
            const avgOpen = openSum / 5;

            // --- é€»è¾‘åˆ¤æ–­ ---

            // A. æ¡æ‹³æš‚åœ
            if(avgOpen < 0.18) {
                state.action = state.action === 'PAUSED' ? 'NORMAL' : 'PAUSED';
                showToast(state.action === 'PAUSED' ? "âœŠ å·²å†»ç»“" : "âœŠ å·²æ¢å¤");
                state.lockTimer = 30;
                dom.stStatus.innerText = "FIST";
                return;
            }
            if(state.action === 'PAUSED') return;

            // B. æåˆæ—‹è½¬
            const pTrigger = state.isPinching ? 0.1 : 0.05;
            if(pinchDist < pTrigger) {
                if(!state.isPinching) {
                    state.isPinching = true;
                    state.pinchStart = {x: thumb.x, y: thumb.y};
                }
                // æ˜ å°„æ‰‹åŠ¿ç§»åŠ¨åˆ°æ—‹è½¬è§’åº¦
                const dx = (thumb.x - state.pinchStart.x) * 5;
                const dy = (thumb.y - state.pinchStart.y) * 5;
                state.targetRot.y -= dx * 0.1; 
                state.targetRot.x += dy * 0.1;
                
                dom.stStatus.innerText = "PINCH ROTATE";
                return;
            } else {
                state.isPinching = false;
            }

            // C. æŒ¥æ‰‹é€»è¾‘
            wristHistory.push({x: wrist.x, y: wrist.y});
            if(wristHistory.length > 8) wristHistory.shift();
            if(wristHistory.length === 8) {
                const dy = wristHistory[7].y - wristHistory[0].y;
                const dx = wristHistory[7].x - wristHistory[0].x;

                if(dy > 0.2) { // ä¸‹æŒ¥
                    state.action = 'FALLING';
                    // é‡ç½®é€Ÿåº¦å‘é‡
                    for(let i=0; i<velocities.length; i++) velocities[i] = (Math.random()-0.5)*0.1;
                    showToast("ğŸ‘‡ é‡åŠ›å´©å¡Œ");
                    state.lockTimer = 25;
                    return;
                }
                if(dy < -0.2) { // ä¸ŠæŒ¥
                    state.action = 'NORMAL';
                    showToast("ğŸ‘† èšåˆé‡ç»„");
                    state.lockTimer = 25;
                    return;
                }
                if(Math.abs(dx) > 0.2) { // ä¾§æŒ¥
                    changeTheme();
                    showToast("â†”ï¸ åˆ‡æ¢ä¸»é¢˜");
                    state.lockTimer = 25;
                    return;
                }
            }

            // D. å¼ æ‰‹ç‚¸è£‚
            if(avgOpen > 0.35) {
                state.action = 'SHATTER';
                dom.stStatus.innerText = "OPEN SHATTER";
            } else if (state.action === 'SHATTER') {
                state.action = 'NORMAL';
            } else {
                dom.stStatus.innerText = "TRACKING";
            }
        }

        /* ==================== è¾…åŠ© ==================== */
        dom.btnCam.addEventListener('click', () => {
            navigator.mediaDevices.getUserMedia({video: true}).then(stream => {
                dom.video.srcObject = stream;
                dom.video.addEventListener('loadeddata', predictLoop);
            });
        });

        function changeTheme() {
            config.currColor = (config.currColor + 1) % config.colors.length;
            particles.material.color.setHex(config.colors[config.currColor]);
        }

        function showToast(msg) {
            dom.toast.innerText = msg;
            dom.toast.style.opacity = 1;
            setTimeout(() => dom.toast.style.opacity = 0, 1500);
        }

        // å¯åŠ¨
        initThree();
        initVision();

    </script>
</body>
</html>
